// PDF Export Utility - SOW Section 8.3: Exportable ACR Reports
// Generates PDF reports for trainee performance, assessment results, and unit analytics

import jsPDF from "jspdf";
import { QuizAttempt } from "./quiz-store";
import { UnitPerformance } from "@/types";

// Common report header
function addReportHeader(doc: jsPDF, title: string, subtitle?: string): number {
  const pageWidth = doc.internal.pageSize.getWidth();

  // Header background
  doc.setFillColor(26, 54, 93); // Army blue
  doc.rect(0, 0, pageWidth, 40, "F");

  // Title
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(18);
  doc.setFont("helvetica", "bold");
  doc.text(title, 14, 20);

  // Subtitle
  if (subtitle) {
    doc.setFontSize(11);
    doc.setFont("helvetica", "normal");
    doc.text(subtitle, 14, 32);
  }

  // Classification
  doc.setFontSize(9);
  doc.setTextColor(255, 200, 0);
  doc.text("RESTRICTED - FOR OFFICIAL USE ONLY", pageWidth - 14, 20, { align: "right" });

  // School of Artillery header
  doc.setTextColor(200, 200, 200);
  doc.setFontSize(8);
  doc.text("School of Artillery, Deolali", pageWidth - 14, 32, { align: "right" });

  return 50; // Return Y position after header
}

// Add footer
function addReportFooter(doc: jsPDF, pageNum: number, totalPages: number): void {
  const pageHeight = doc.internal.pageSize.getHeight();
  const pageWidth = doc.internal.pageSize.getWidth();

  doc.setFontSize(8);
  doc.setTextColor(128, 128, 128);
  doc.text(
    `Generated by OAKSIP - AI-Based Offline Artillery Intelligence Platform`,
    14,
    pageHeight - 10
  );
  doc.text(
    `Page ${pageNum} of ${totalPages}`,
    pageWidth - 14,
    pageHeight - 10,
    { align: "right" }
  );
  doc.text(
    `Generated on: ${new Date().toLocaleString("en-IN", { timeZone: "Asia/Kolkata" })}`,
    pageWidth / 2,
    pageHeight - 10,
    { align: "center" }
  );
}

// Section title
function addSectionTitle(doc: jsPDF, title: string, y: number): number {
  doc.setFillColor(240, 240, 240);
  doc.rect(14, y - 4, doc.internal.pageSize.getWidth() - 28, 10, "F");
  doc.setTextColor(26, 54, 93);
  doc.setFontSize(12);
  doc.setFont("helvetica", "bold");
  doc.text(title, 14, y + 3);
  return y + 15;
}

// Key-value row
function addKeyValueRow(doc: jsPDF, key: string, value: string, y: number, indent: number = 14): number {
  doc.setFontSize(10);
  doc.setTextColor(80, 80, 80);
  doc.setFont("helvetica", "normal");
  doc.text(key + ":", indent, y);
  doc.setTextColor(0, 0, 0);
  doc.setFont("helvetica", "bold");
  doc.text(value, indent + 50, y);
  return y + 7;
}

// Progress bar
function addProgressBar(
  doc: jsPDF,
  label: string,
  value: number,
  maxValue: number,
  y: number,
  color: [number, number, number] = [34, 139, 34]
): number {
  const percentage = Math.round((value / maxValue) * 100);
  const barWidth = 100;
  const barHeight = 8;
  const x = 70;

  doc.setFontSize(9);
  doc.setTextColor(80, 80, 80);
  doc.text(label, 14, y + 6);

  // Background bar
  doc.setFillColor(220, 220, 220);
  doc.roundedRect(x, y, barWidth, barHeight, 2, 2, "F");

  // Progress bar
  const progressWidth = (percentage / 100) * barWidth;
  doc.setFillColor(...color);
  doc.roundedRect(x, y, progressWidth, barHeight, 2, 2, "F");

  // Value
  doc.setTextColor(0, 0, 0);
  doc.text(`${percentage}%`, x + barWidth + 5, y + 6);

  return y + 14;
}

// Table
function addTable(
  doc: jsPDF,
  headers: string[],
  rows: string[][],
  y: number,
  columnWidths?: number[]
): number {
  const pageWidth = doc.internal.pageSize.getWidth();
  const tableWidth = pageWidth - 28;
  const defaultColWidth = tableWidth / headers.length;
  const colWidths = columnWidths || headers.map(() => defaultColWidth);

  // Header
  doc.setFillColor(26, 54, 93);
  doc.rect(14, y, tableWidth, 10, "F");
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(9);
  doc.setFont("helvetica", "bold");

  let xPos = 14;
  headers.forEach((header, i) => {
    doc.text(header, xPos + 2, y + 7);
    xPos += colWidths[i];
  });

  y += 10;

  // Rows
  doc.setTextColor(0, 0, 0);
  doc.setFont("helvetica", "normal");

  rows.forEach((row, rowIdx) => {
    // Alternate row colors
    if (rowIdx % 2 === 0) {
      doc.setFillColor(250, 250, 250);
      doc.rect(14, y, tableWidth, 8, "F");
    }

    xPos = 14;
    row.forEach((cell, colIdx) => {
      doc.text(cell.substring(0, 25), xPos + 2, y + 6); // Truncate long text
      xPos += colWidths[colIdx];
    });
    y += 8;
  });

  return y + 5;
}

// Generate Trainee ACR Report
export function generateTraineeACRReport(
  traineeName: string,
  traineeId: string,
  course: string,
  batch: string,
  attempts: QuizAttempt[]
): jsPDF {
  const doc = new jsPDF();
  let y = addReportHeader(doc, "TRAINEE ASSESSMENT REPORT", `Annual Confidential Report - ${course}`);

  // Trainee Details Section
  y = addSectionTitle(doc, "TRAINEE DETAILS", y);
  y = addKeyValueRow(doc, "Name", traineeName, y);
  y = addKeyValueRow(doc, "ID", traineeId, y);
  y = addKeyValueRow(doc, "Course", course, y);
  y = addKeyValueRow(doc, "Batch", batch, y);
  y += 5;

  // Performance Summary
  y = addSectionTitle(doc, "PERFORMANCE SUMMARY", y);

  const totalAttempts = attempts.length;
  const avgScore = totalAttempts > 0
    ? Math.round(attempts.reduce((sum, a) => sum + (a.score / a.totalQuestions) * 100, 0) / totalAttempts)
    : 0;
  const avgNetScore = totalAttempts > 0
    ? Math.round(attempts.reduce((sum, a) => sum + (a.netScore / a.totalQuestions) * 100, 0) / totalAttempts)
    : 0;
  const totalTimeSpent = attempts.reduce((sum, a) => sum + a.timeSpent, 0);

  y = addKeyValueRow(doc, "Total Assessments", totalAttempts.toString(), y);
  y = addKeyValueRow(doc, "Average Score", `${avgScore}%`, y);
  y = addKeyValueRow(doc, "Average Net Score", `${avgNetScore}% (with negative marking)`, y);
  y = addKeyValueRow(doc, "Total Time", `${Math.round(totalTimeSpent / 60)} minutes`, y);
  y += 5;

  // Performance by Topic
  if (attempts.length > 0) {
    y = addSectionTitle(doc, "TOPIC-WISE PERFORMANCE", y);

    // Aggregate topic scores across all attempts
    const topicAggregates: Record<string, { correct: number; total: number }> = {};
    attempts.forEach((attempt) => {
      attempt.topicBreakdown?.forEach((topic) => {
        if (!topicAggregates[topic.topic]) {
          topicAggregates[topic.topic] = { correct: 0, total: 0 };
        }
        topicAggregates[topic.topic].correct += topic.correct;
        topicAggregates[topic.topic].total += topic.total;
      });
    });

    Object.entries(topicAggregates).forEach(([topic, scores]) => {
      const percentage = Math.round((scores.correct / scores.total) * 100);
      const color: [number, number, number] = percentage >= 70
        ? [34, 139, 34]
        : percentage >= 50
          ? [255, 165, 0]
          : [220, 20, 60];
      y = addProgressBar(doc, topic, scores.correct, scores.total, y, color);
    });
    y += 5;
  }

  // Recent Assessments Table
  y = addSectionTitle(doc, "RECENT ASSESSMENTS", y);
  const recentAttempts = attempts.slice(0, 10);
  const tableData = recentAttempts.map((a) => [
    new Date(a.date).toLocaleDateString("en-IN"),
    a.category,
    a.difficulty,
    `${a.score}/${a.totalQuestions}`,
    `${Math.round((a.score / a.totalQuestions) * 100)}%`,
    `${Math.floor(a.timeSpent / 60)}m ${a.timeSpent % 60}s`,
  ]);
  y = addTable(doc, ["Date", "Category", "Difficulty", "Score", "%", "Time"], tableData, y);

  // Remarks
  y += 10;
  y = addSectionTitle(doc, "INSTRUCTOR REMARKS", y);
  doc.setFontSize(10);
  doc.setTextColor(80, 80, 80);

  const performanceLevel = avgScore >= 85
    ? "OUTSTANDING"
    : avgScore >= 70
      ? "ABOVE AVERAGE"
      : avgScore >= 50
        ? "AVERAGE"
        : "NEEDS IMPROVEMENT";

  doc.text(`Overall Performance: ${performanceLevel}`, 14, y);
  y += 8;

  // Signature block
  y += 20;
  doc.setDrawColor(0, 0, 0);
  doc.line(14, y, 80, y);
  doc.line(doc.internal.pageSize.getWidth() - 80, y, doc.internal.pageSize.getWidth() - 14, y);
  y += 5;
  doc.setFontSize(9);
  doc.text("Instructor Signature", 14, y);
  doc.text("Course Officer Signature", doc.internal.pageSize.getWidth() - 80, y);

  addReportFooter(doc, 1, 1);

  return doc;
}

// Generate Unit Performance Report
export function generateUnitPerformanceReport(
  unitName: string,
  unitPerformance: UnitPerformance[],
  period: string
): jsPDF {
  const doc = new jsPDF();
  let y = addReportHeader(doc, "UNIT PERFORMANCE REPORT", `Training Analytics - ${period}`);

  // Unit Overview
  y = addSectionTitle(doc, "UNIT OVERVIEW", y);
  y = addKeyValueRow(doc, "Unit", unitName, y);
  y = addKeyValueRow(doc, "Reporting Period", period, y);
  y = addKeyValueRow(doc, "Total Batteries", unitPerformance.length.toString(), y);
  y += 5;

  // Battery Performance Table
  y = addSectionTitle(doc, "BATTERY-WISE PERFORMANCE", y);
  const tableData = unitPerformance.map((u) => [
    u.unitName,
    `${u.completionRate}%`,
    u.averageScore.toFixed(1),
    `${u.passRate}%`,
  ]);
  y = addTable(
    doc,
    ["Battery", "Completion", "Avg Score", "Pass Rate"],
    tableData,
    y,
    [80, 40, 40, 40]
  );

  // Performance Bars
  y += 10;
  y = addSectionTitle(doc, "COMPARATIVE ANALYSIS", y);
  unitPerformance.forEach((unit) => {
    const color: [number, number, number] = unit.passRate >= 80
      ? [34, 139, 34]
      : unit.passRate >= 60
        ? [255, 165, 0]
        : [220, 20, 60];
    y = addProgressBar(doc, unit.unitName, unit.passRate, 100, y, color);
  });

  // Summary Statistics
  y += 10;
  y = addSectionTitle(doc, "SUMMARY STATISTICS", y);
  const avgCompletion = Math.round(
    unitPerformance.reduce((sum, u) => sum + u.completionRate, 0) / unitPerformance.length
  );
  const avgPassRate = Math.round(
    unitPerformance.reduce((sum, u) => sum + u.passRate, 0) / unitPerformance.length
  );
  const avgScore = (
    unitPerformance.reduce((sum, u) => sum + u.averageScore, 0) / unitPerformance.length
  ).toFixed(1);

  y = addKeyValueRow(doc, "Avg Completion Rate", `${avgCompletion}%`, y);
  y = addKeyValueRow(doc, "Avg Pass Rate", `${avgPassRate}%`, y);
  y = addKeyValueRow(doc, "Avg Score", avgScore, y);

  addReportFooter(doc, 1, 1);

  return doc;
}

// Generate Assessment Result Report
export function generateAssessmentResultReport(
  assessmentName: string,
  assessmentType: string,
  date: Date,
  results: Array<{
    traineeName: string;
    traineeId: string;
    score: number;
    totalMarks: number;
    passed: boolean;
  }>
): jsPDF {
  const doc = new jsPDF();
  let y = addReportHeader(doc, "ASSESSMENT RESULTS", assessmentName);

  // Assessment Details
  y = addSectionTitle(doc, "ASSESSMENT DETAILS", y);
  y = addKeyValueRow(doc, "Assessment", assessmentName, y);
  y = addKeyValueRow(doc, "Type", assessmentType, y);
  y = addKeyValueRow(doc, "Date", date.toLocaleDateString("en-IN"), y);
  y = addKeyValueRow(doc, "Total Candidates", results.length.toString(), y);
  y += 5;

  // Statistics
  y = addSectionTitle(doc, "STATISTICS", y);
  const passed = results.filter((r) => r.passed).length;
  const avgScore = Math.round(
    results.reduce((sum, r) => sum + (r.score / r.totalMarks) * 100, 0) / results.length
  );
  const highest = Math.max(...results.map((r) => (r.score / r.totalMarks) * 100));
  const lowest = Math.min(...results.map((r) => (r.score / r.totalMarks) * 100));

  y = addKeyValueRow(doc, "Pass Rate", `${Math.round((passed / results.length) * 100)}%`, y);
  y = addKeyValueRow(doc, "Average Score", `${avgScore}%`, y);
  y = addKeyValueRow(doc, "Highest Score", `${Math.round(highest)}%`, y);
  y = addKeyValueRow(doc, "Lowest Score", `${Math.round(lowest)}%`, y);
  y += 5;

  // Results Table
  y = addSectionTitle(doc, "INDIVIDUAL RESULTS", y);
  const tableData = results
    .sort((a, b) => b.score - a.score)
    .map((r, idx) => [
      (idx + 1).toString(),
      r.traineeName,
      r.traineeId,
      `${r.score}/${r.totalMarks}`,
      `${Math.round((r.score / r.totalMarks) * 100)}%`,
      r.passed ? "PASS" : "FAIL",
    ]);
  addTable(
    doc,
    ["Rank", "Name", "ID", "Score", "%", "Status"],
    tableData,
    y,
    [20, 50, 40, 30, 25, 25]
  );

  addReportFooter(doc, 1, 1);

  return doc;
}

// Export utility functions
export function downloadPDF(doc: jsPDF, filename: string): void {
  doc.save(filename);
}

export function getPDFBlob(doc: jsPDF): Blob {
  return doc.output("blob");
}

export function getPDFDataUri(doc: jsPDF): string {
  return doc.output("datauristring");
}
